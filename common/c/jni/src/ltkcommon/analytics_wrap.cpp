/*
Copyright (c) 2018, TeleCommunication Systems, Inc.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
   * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the TeleCommunication Systems, Inc., nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED. IN NO EVENT SHALL TELECOMMUNICATION SYSTEMS, INC.BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 3.0.2
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */

#define SWIGJAVA
#define SWIG_DIRECTORS


#ifdef __cplusplus
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigMovePointer {
    T *ptr;
    SwigMovePointer(T *p) : ptr(p) { }
    ~SwigMovePointer() { delete ptr; }
    SwigMovePointer& operator=(SwigMovePointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigMovePointer tmp(new T(t)); pointer = tmp; return *this; }
  operator T&() const { return *pointer.ptr; }
  T *operator&() { return pointer.ptr; }
};

template <typename T> T SwigValueInit() {
  return T();
}
#endif

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__))
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__))
# else
#   define SWIGUNUSED
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#  ifndef GCC_HASCLASSVISIBILITY
#    define GCC_HASCLASSVISIBILITY
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif



/* Fix for jlong on some versions of gcc on Windows */
#if defined(__GNUC__) && !defined(__INTEL_COMPILER)
  typedef long long __int64;
#endif

/* Fix for jlong on 64-bit x86 Solaris */
#if defined(__x86_64)
# ifdef _LP64
#   undef _LP64
# endif
#endif

#include <jni.h>
#include <stdlib.h>
#include <string.h>


/* Support for throwing Java exceptions */
typedef enum {
  SWIG_JavaOutOfMemoryError = 1,
  SWIG_JavaIOException,
  SWIG_JavaRuntimeException,
  SWIG_JavaIndexOutOfBoundsException,
  SWIG_JavaArithmeticException,
  SWIG_JavaIllegalArgumentException,
  SWIG_JavaNullPointerException,
  SWIG_JavaDirectorPureVirtual,
  SWIG_JavaUnknownError
} SWIG_JavaExceptionCodes;

typedef struct {
  SWIG_JavaExceptionCodes code;
  const char *java_exception;
} SWIG_JavaExceptions_t;


static void SWIGUNUSED SWIG_JavaThrowException(JNIEnv *jenv, SWIG_JavaExceptionCodes code, const char *msg) {
  jclass excep;
  static const SWIG_JavaExceptions_t java_exceptions[] = {
    { SWIG_JavaOutOfMemoryError, "java/lang/OutOfMemoryError" },
    { SWIG_JavaIOException, "java/io/IOException" },
    { SWIG_JavaRuntimeException, "java/lang/RuntimeException" },
    { SWIG_JavaIndexOutOfBoundsException, "java/lang/IndexOutOfBoundsException" },
    { SWIG_JavaArithmeticException, "java/lang/ArithmeticException" },
    { SWIG_JavaIllegalArgumentException, "java/lang/IllegalArgumentException" },
    { SWIG_JavaNullPointerException, "java/lang/NullPointerException" },
    { SWIG_JavaDirectorPureVirtual, "java/lang/RuntimeException" },
    { SWIG_JavaUnknownError,  "java/lang/UnknownError" },
    { (SWIG_JavaExceptionCodes)0,  "java/lang/UnknownError" }
  };
  const SWIG_JavaExceptions_t *except_ptr = java_exceptions;

  while (except_ptr->code != code && except_ptr->code)
    except_ptr++;

  jenv->ExceptionClear();
  excep = jenv->FindClass(except_ptr->java_exception);
  if (excep)
    jenv->ThrowNew(excep, msg);
}


/* Contract support */

#define SWIG_contract_assert(nullreturn, expr, msg) if (!(expr)) {SWIG_JavaThrowException(jenv, SWIG_JavaIllegalArgumentException, msg); return nullreturn; } else

/* -----------------------------------------------------------------------------
 * director.swg
 *
 * This file contains support for director classes so that Java proxy
 * methods can be called from C++.
 * ----------------------------------------------------------------------------- */

#if defined(DEBUG_DIRECTOR_OWNED) || defined(DEBUG_DIRECTOR_EXCEPTION)
#include <iostream>
#endif

#include <exception>

namespace Swig {

  /* Java object wrapper */
  class JObjectWrapper {
  public:
    JObjectWrapper() : jthis_(NULL), weak_global_(true) {
    }

    ~JObjectWrapper() {
      jthis_ = NULL;
      weak_global_ = true;
    }

    bool set(JNIEnv *jenv, jobject jobj, bool mem_own, bool weak_global) {
      if (!jthis_) {
        weak_global_ = weak_global || !mem_own; // hold as weak global if explicitly requested or not owned
        if (jobj)
          jthis_ = weak_global_ ? jenv->NewWeakGlobalRef(jobj) : jenv->NewGlobalRef(jobj);
#if defined(DEBUG_DIRECTOR_OWNED)
        std::cout << "JObjectWrapper::set(" << jobj << ", " << (weak_global ? "weak_global" : "global_ref") << ") -> " << jthis_ << std::endl;
#endif
        return true;
      } else {
#if defined(DEBUG_DIRECTOR_OWNED)
        std::cout << "JObjectWrapper::set(" << jobj << ", " << (weak_global ? "weak_global" : "global_ref") << ") -> already set" << std::endl;
#endif
        return false;
      }
    }

    jobject get(JNIEnv *jenv) const {
#if defined(DEBUG_DIRECTOR_OWNED)
      std::cout << "JObjectWrapper::get(";
      if (jthis_)
        std::cout << jthis_;
      else
        std::cout << "null";
      std::cout << ") -> return new local ref" << std::endl;
#endif
      return (jthis_ ? jenv->NewLocalRef(jthis_) : jthis_);
    }

    void release(JNIEnv *jenv) {
#if defined(DEBUG_DIRECTOR_OWNED)
      std::cout << "JObjectWrapper::release(" << jthis_ << "): " << (weak_global_ ? "weak global ref" : "global ref") << std::endl;
#endif
      if (jthis_) {
        if (weak_global_) {
          if (jenv->IsSameObject(jthis_, NULL) == JNI_FALSE)
            jenv->DeleteWeakGlobalRef((jweak)jthis_);
        } else
          jenv->DeleteGlobalRef(jthis_);
      }

      jthis_ = NULL;
      weak_global_ = true;
    }

    /* Only call peek if you know what you are doing wrt to weak/global references */
    jobject peek() {
      return jthis_;
    }

    /* Java proxy releases ownership of C++ object, C++ object is now
       responsible for destruction (creates NewGlobalRef to pin Java proxy) */
    void java_change_ownership(JNIEnv *jenv, jobject jself, bool take_or_release) {
      if (take_or_release) {  /* Java takes ownership of C++ object's lifetime. */
        if (!weak_global_) {
          jenv->DeleteGlobalRef(jthis_);
          jthis_ = jenv->NewWeakGlobalRef(jself);
          weak_global_ = true;
        }
      } else {
    /* Java releases ownership of C++ object's lifetime */
        if (weak_global_) {
          jenv->DeleteWeakGlobalRef((jweak)jthis_);
          jthis_ = jenv->NewGlobalRef(jself);
          weak_global_ = false;
        }
      }
    }

  private:
    /* pointer to Java object */
    jobject jthis_;
    /* Local or global reference flag */
    bool weak_global_;
  };

  /* director base class */
  class Director {
    /* pointer to Java virtual machine */
    JavaVM *swig_jvm_;

  protected:
#if defined (_MSC_VER) && (_MSC_VER<1300)
    class JNIEnvWrapper;
    friend class JNIEnvWrapper;
#endif
    /* Utility class for managing the JNI environment */
    class JNIEnvWrapper {
      const Director *director_;
      JNIEnv *jenv_;
      int env_status;
    public:
      JNIEnvWrapper(const Director *director) : director_(director), jenv_(0), env_status(0) {
#if defined(__ANDROID__)
        JNIEnv **jenv = &jenv_;
#else
        void **jenv = (void **)&jenv_;
#endif
        env_status = director_->swig_jvm_->GetEnv((void **)&jenv_, JNI_VERSION_1_2);
#if defined(SWIG_JAVA_ATTACH_CURRENT_THREAD_AS_DAEMON)
        // Attach a daemon thread to the JVM. Useful when the JVM should not wait for
        // the thread to exit upon shutdown. Only for jdk-1.4 and later.
        director_->swig_jvm_->AttachCurrentThreadAsDaemon(jenv, NULL);
#else
        director_->swig_jvm_->AttachCurrentThread(jenv, NULL);
#endif
      }
      ~JNIEnvWrapper() {
#if !defined(SWIG_JAVA_NO_DETACH_CURRENT_THREAD)
        // Some JVMs, eg jdk-1.4.2 and lower on Solaris have a bug and crash with the DetachCurrentThread call.
        // However, without this call, the JVM hangs on exit when the thread was not created by the JVM and creates a memory leak.
        if (env_status == JNI_EDETACHED)
          director_->swig_jvm_->DetachCurrentThread();
#endif
      }
      JNIEnv *getJNIEnv() const {
        return jenv_;
      }
    };

    /* Java object wrapper */
    JObjectWrapper swig_self_;

    /* Disconnect director from Java object */
    void swig_disconnect_director_self(const char *disconn_method) {
      JNIEnvWrapper jnienv(this) ;
      JNIEnv *jenv = jnienv.getJNIEnv() ;
      jobject jobj = swig_self_.get(jenv);
#if defined(DEBUG_DIRECTOR_OWNED)
      std::cout << "Swig::Director::disconnect_director_self(" << jobj << ")" << std::endl;
#endif
      if (jobj && jenv->IsSameObject(jobj, NULL) == JNI_FALSE) {
        jmethodID disconn_meth = jenv->GetMethodID(jenv->GetObjectClass(jobj), disconn_method, "()V");
        if (disconn_meth) {
#if defined(DEBUG_DIRECTOR_OWNED)
          std::cout << "Swig::Director::disconnect_director_self upcall to " << disconn_method << std::endl;
#endif
          jenv->CallVoidMethod(jobj, disconn_meth);
        }
      }
      jenv->DeleteLocalRef(jobj);
    }

  public:
    Director(JNIEnv *jenv) : swig_jvm_((JavaVM *) NULL), swig_self_() {
      /* Acquire the Java VM pointer */
      jenv->GetJavaVM(&swig_jvm_);
    }

    virtual ~Director() {
      JNIEnvWrapper jnienv(this) ;
      JNIEnv *jenv = jnienv.getJNIEnv() ;
      swig_self_.release(jenv);
    }

    bool swig_set_self(JNIEnv *jenv, jobject jself, bool mem_own, bool weak_global) {
      return swig_self_.set(jenv, jself, mem_own, weak_global);
    }

    jobject swig_get_self(JNIEnv *jenv) const {
      return swig_self_.get(jenv);
    }

    // Change C++ object's ownership, relative to Java
    void swig_java_change_ownership(JNIEnv *jenv, jobject jself, bool take_or_release) {
      swig_self_.java_change_ownership(jenv, jself, take_or_release);
    }
  };


  // Utility classes and functions for exception handling.

  // Simple holder for a Java string during exception handling, providing access to a c-style string
  class JavaString {
  public:
    JavaString(JNIEnv *jenv, jstring jstr) : jenv_(jenv), jstr_(jstr), cstr_(0) {
      if (jenv_ && jstr_)
    cstr_ = (const char *) jenv_->GetStringUTFChars(jstr_, NULL);
    }

    ~JavaString() {
      if (jenv_ && jstr_ && cstr_)
    jenv_->ReleaseStringUTFChars(jstr_, cstr_);
    }

    const char *c_str(const char *null_string = "null JavaString") const {
      return cstr_ ? cstr_ : null_string;
    }

  private:
    // non-copyable
    JavaString(const JavaString &);
    JavaString &operator=(const JavaString &);

    JNIEnv *jenv_;
    jstring jstr_;
    const char *cstr_;
  };

  // Helper class to extract the exception message from a Java throwable
  class JavaExceptionMessage {
  public:
    JavaExceptionMessage(JNIEnv *jenv, jthrowable throwable) : message_(jenv, exceptionMessageFromThrowable(jenv, throwable)) {
    }

    const char *message() const {
      return message_.c_str("Could not get exception message in JavaExceptionMessage");
    }

  private:
    // non-copyable
    JavaExceptionMessage(const JavaExceptionMessage &);
    JavaExceptionMessage &operator=(const JavaExceptionMessage &);

    // Get exception message by calling Java method Throwable.getMessage()
    static jstring exceptionMessageFromThrowable(JNIEnv *jenv, jthrowable throwable) {
      jstring jmsg = NULL;
      if (jenv && throwable) {
    jenv->ExceptionClear(); // Cannot invoke methods with any pending exceptions
    jclass throwclz = jenv->GetObjectClass(throwable);
    if (throwclz) {
      // All Throwable classes have a getMessage() method, so call it to extract the exception message
      jmethodID getMessageMethodID = jenv->GetMethodID(throwclz, "getMessage", "()Ljava/lang/String;");
      if (getMessageMethodID)
        jmsg = (jstring)jenv->CallObjectMethod(throwable, getMessageMethodID);
    }
    if (jmsg == NULL && jenv->ExceptionCheck())
      jenv->ExceptionClear();
      }
      return jmsg;
    }

    JavaString message_;
  };

  // C++ Exception class for handling Java exceptions thrown during a director method Java upcall
  class DirectorException : public std::exception {
  public:

    // Construct exception from a Java throwable
    DirectorException(JNIEnv *jenv, jthrowable throwable) : classname_(0), msg_(0) {

      // Call Java method Object.getClass().getName() to obtain the throwable's class name (delimited by '/')
      if (throwable) {
    jclass throwclz = jenv->GetObjectClass(throwable);
    if (throwclz) {
      jclass clzclz = jenv->GetObjectClass(throwclz);
      if (clzclz) {
        jmethodID getNameMethodID = jenv->GetMethodID(clzclz, "getName", "()Ljava/lang/String;");
        if (getNameMethodID) {
          jstring jstr_classname = (jstring)(jenv->CallObjectMethod(throwclz, getNameMethodID));
              // Copy strings, since there is no guarantee that jenv will be active when handled
              if (jstr_classname) {
                JavaString jsclassname(jenv, jstr_classname);
                const char *classname = jsclassname.c_str(0);
                if (classname)
                  classname_ = copypath(classname);
              }
        }
      }
    }
      }

      JavaExceptionMessage exceptionmsg(jenv, throwable);
      msg_ = copystr(exceptionmsg.message());
    }

    // More general constructor for handling as a java.lang.RuntimeException
    DirectorException(const char *msg) : classname_(0), msg_(copystr(msg ? msg : "Unspecified DirectorException message")) {
    }

    ~DirectorException() throw() {
      delete[] classname_;
      delete[] msg_;
    }

    const char *what() const throw() {
      return msg_;
    }

    // Reconstruct and raise/throw the Java Exception that caused the DirectorException
    // Note that any error in the JNI exception handling results in a Java RuntimeException
    void raiseJavaException(JNIEnv *jenv) const {
      if (jenv) {
    jenv->ExceptionClear();

    jmethodID ctorMethodID = 0;
    jclass throwableclass = 0;
        if (classname_) {
          throwableclass = jenv->FindClass(classname_);
          if (throwableclass)
            ctorMethodID = jenv->GetMethodID(throwableclass, "<init>", "(Ljava/lang/String;)V");
    }

    if (ctorMethodID) {
      jenv->ThrowNew(throwableclass, what());
    } else {
      SWIG_JavaThrowException(jenv, SWIG_JavaRuntimeException, what());
    }
      }
    }

  private:
    static char *copypath(const char *srcmsg) {
      char *target = copystr(srcmsg);
      for (char *c=target; *c; ++c) {
        if ('.' == *c)
          *c = '/';
      }
      return target;
    }

    static char *copystr(const char *srcmsg) {
      char *target = 0;
      if (srcmsg) {
    int msglen = strlen(srcmsg) + 1;
    target = new char[msglen];
    strncpy(target, srcmsg, msglen);
      }
      return target;
    }

    const char *classname_;
    const char *msg_;
  };

  // Helper method to determine if a Java throwable matches a particular Java class type
  bool ExceptionMatches(JNIEnv *jenv, jthrowable throwable, const char *classname) {
    bool matches = false;

    if (throwable && jenv && classname) {
      // Exceptions need to be cleared for correct behavior.
      // The caller of ExceptionMatches should restore pending exceptions if desired -
      // the caller already has the throwable.
      jenv->ExceptionClear();

      jclass clz = jenv->FindClass(classname);
      if (clz) {
    jclass classclz = jenv->GetObjectClass(clz);
    jmethodID isInstanceMethodID = jenv->GetMethodID(classclz, "isInstance", "(Ljava/lang/Object;)Z");
    if (isInstanceMethodID) {
      matches = jenv->CallBooleanMethod(clz, isInstanceMethodID, throwable) != 0;
    }
      }

#if defined(DEBUG_DIRECTOR_EXCEPTION)
      if (jenv->ExceptionCheck()) {
        // Typically occurs when an invalid classname argument is passed resulting in a ClassNotFoundException
        JavaExceptionMessage exc(jenv, jenv->ExceptionOccurred());
        std::cout << "Error: ExceptionMatches: class '" << classname << "' : " << exc.message() << std::endl;
      }
#endif
    }
    return matches;
  }

}

namespace Swig {
  namespace {
    jclass jclass_analytics_wrapperJNI = NULL;
    jmethodID director_methids[1];
  }
}

#include <string>


#include "analyticsengine.h"



/* ---------------------------------------------------
 * C++ director class methods
 * --------------------------------------------------- */

#include "analytics_wrap.h"

SwigDirector_AnalyticsListener::SwigDirector_AnalyticsListener(JNIEnv *jenv) : nbcommon::AnalyticsListener(), Swig::Director(jenv) {
}

void SwigDirector_AnalyticsListener::OnSessionCreated(std::string const &oldSessionId, std::string const &newSessionId) {
  JNIEnvWrapper swigjnienv(this) ;
  JNIEnv * jenv = swigjnienv.getJNIEnv() ;
  jobject swigjobj = (jobject) NULL ;
  jbyteArray joldSessionId = 0 ;
  jbyteArray jnewSessionId = 0 ;

  if (!swig_override[0]) {
    SWIG_JavaThrowException(JNIEnvWrapper(this).getJNIEnv(), SWIG_JavaDirectorPureVirtual, "Attempted to invoke pure virtual method nbcommon::AnalyticsListener::OnSessionCreated.");
    return;
  }
  swigjobj = swig_get_self(jenv);
  if (swigjobj && jenv->IsSameObject(swigjobj, NULL) == JNI_FALSE) {
    joldSessionId = jenv->NewByteArray(oldSessionId.length());
	jenv->SetByteArrayRegion(joldSessionId, 0, oldSessionId.length(), (jbyte*)oldSessionId.c_str());
    jnewSessionId = jenv->NewByteArray(newSessionId.length());
	jenv->SetByteArrayRegion(jnewSessionId, 0, newSessionId.length(), (jbyte*)newSessionId.c_str());
    jenv->CallStaticVoidMethod(Swig::jclass_analytics_wrapperJNI, Swig::director_methids[0], swigjobj, joldSessionId, jnewSessionId);
    jthrowable swigerror = jenv->ExceptionOccurred();
    if (swigerror) {
      jenv->ExceptionClear();
      throw Swig::DirectorException(jenv, swigerror);
    }

  } else {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null upcall object in nbcommon::AnalyticsListener::OnSessionCreated ");
  }
  if (swigjobj) jenv->DeleteLocalRef(swigjobj);
}

void SwigDirector_AnalyticsListener::swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global) {
  static struct {
    const char *mname;
    const char *mdesc;
    jmethodID base_methid;
  } methods[] = {
    {
      "OnSessionCreated", "([B[B)V", NULL
    }
  };

  static jclass baseclass = 0 ;

  if (swig_set_self(jenv, jself, swig_mem_own, weak_global)) {
    if (!baseclass) {
      baseclass = jenv->FindClass("com/navbuilder/nb/analytics/internal/jni/AnalyticsListener");
      if (!baseclass) return;
      baseclass = (jclass) jenv->NewGlobalRef(baseclass);
    }
    bool derived = (jenv->IsSameObject(baseclass, jcls) ? false : true);
    for (int i = 0; i < 1; ++i) {
      if (!methods[i].base_methid) {
        methods[i].base_methid = jenv->GetMethodID(baseclass, methods[i].mname, methods[i].mdesc);
        if (!methods[i].base_methid) return;
      }
      swig_override[i] = false;
      if (derived) {
        jmethodID methid = jenv->GetMethodID(jcls, methods[i].mname, methods[i].mdesc);
        swig_override[i] = (methid != methods[i].base_methid);
        jenv->ExceptionClear();
      }
    }
  }
}

#include "nativeltkcontext.h"

#ifdef __cplusplus
extern "C" {
#endif

SWIGEXPORT void JNICALL Java_com_navbuilder_nb_analytics_internal_jni_analytics_1wrapperJNI_AnalyticsWifiConfig_1max_1horizontal_1uncertainty_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  nbcommon::AnalyticsWifiConfig *arg1 = (nbcommon::AnalyticsWifiConfig *) 0 ;
  uint32 arg2 ;

  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(nbcommon::AnalyticsWifiConfig **)&jarg1;
  arg2 = (uint32)jarg2;
  if (arg1) (arg1)->max_horizontal_uncertainty = arg2;
}


SWIGEXPORT jint JNICALL Java_com_navbuilder_nb_analytics_internal_jni_analytics_1wrapperJNI_AnalyticsWifiConfig_1max_1horizontal_1uncertainty_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  nbcommon::AnalyticsWifiConfig *arg1 = (nbcommon::AnalyticsWifiConfig *) 0 ;
  uint32 result;

  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(nbcommon::AnalyticsWifiConfig **)&jarg1;
  result = (uint32) ((arg1)->max_horizontal_uncertainty);
  jresult = (jint)result;
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_navbuilder_nb_analytics_internal_jni_analytics_1wrapperJNI_AnalyticsWifiConfig_1max_1speed_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  nbcommon::AnalyticsWifiConfig *arg1 = (nbcommon::AnalyticsWifiConfig *) 0 ;
  uint32 arg2 ;

  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(nbcommon::AnalyticsWifiConfig **)&jarg1;
  arg2 = (uint32)jarg2;
  if (arg1) (arg1)->max_speed = arg2;
}


SWIGEXPORT jint JNICALL Java_com_navbuilder_nb_analytics_internal_jni_analytics_1wrapperJNI_AnalyticsWifiConfig_1max_1speed_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  nbcommon::AnalyticsWifiConfig *arg1 = (nbcommon::AnalyticsWifiConfig *) 0 ;
  uint32 result;

  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(nbcommon::AnalyticsWifiConfig **)&jarg1;
  result = (uint32) ((arg1)->max_speed);
  jresult = (jint)result;
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_navbuilder_nb_analytics_internal_jni_analytics_1wrapperJNI_AnalyticsWifiConfig_1collection_1interval_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  nbcommon::AnalyticsWifiConfig *arg1 = (nbcommon::AnalyticsWifiConfig *) 0 ;
  uint32 arg2 ;

  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(nbcommon::AnalyticsWifiConfig **)&jarg1;
  arg2 = (uint32)jarg2;
  if (arg1) (arg1)->collection_interval = arg2;
}


SWIGEXPORT jint JNICALL Java_com_navbuilder_nb_analytics_internal_jni_analytics_1wrapperJNI_AnalyticsWifiConfig_1collection_1interval_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  nbcommon::AnalyticsWifiConfig *arg1 = (nbcommon::AnalyticsWifiConfig *) 0 ;
  uint32 result;

  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(nbcommon::AnalyticsWifiConfig **)&jarg1;
  result = (uint32) ((arg1)->collection_interval);
  jresult = (jint)result;
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_navbuilder_nb_analytics_internal_jni_analytics_1wrapperJNI_AnalyticsWifiConfig_1minimum_1distance_1delta_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  nbcommon::AnalyticsWifiConfig *arg1 = (nbcommon::AnalyticsWifiConfig *) 0 ;
  uint32 arg2 ;

  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(nbcommon::AnalyticsWifiConfig **)&jarg1;
  arg2 = (uint32)jarg2;
  if (arg1) (arg1)->minimum_distance_delta = arg2;
}


SWIGEXPORT jint JNICALL Java_com_navbuilder_nb_analytics_internal_jni_analytics_1wrapperJNI_AnalyticsWifiConfig_1minimum_1distance_1delta_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  nbcommon::AnalyticsWifiConfig *arg1 = (nbcommon::AnalyticsWifiConfig *) 0 ;
  uint32 result;

  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(nbcommon::AnalyticsWifiConfig **)&jarg1;
  result = (uint32) ((arg1)->minimum_distance_delta);
  jresult = (jint)result;
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_navbuilder_nb_analytics_internal_jni_analytics_1wrapperJNI_new_1AnalyticsWifiConfig(JNIEnv *jenv, jclass jcls) {
  jlong jresult = 0 ;
  nbcommon::AnalyticsWifiConfig *result = 0 ;

  (void)jenv;
  (void)jcls;
  result = (nbcommon::AnalyticsWifiConfig *)new nbcommon::AnalyticsWifiConfig();
  *(nbcommon::AnalyticsWifiConfig **)&jresult = result;
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_navbuilder_nb_analytics_internal_jni_analytics_1wrapperJNI_delete_1AnalyticsWifiConfig(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  nbcommon::AnalyticsWifiConfig *arg1 = (nbcommon::AnalyticsWifiConfig *) 0 ;

  (void)jenv;
  (void)jcls;
  arg1 = *(nbcommon::AnalyticsWifiConfig **)&jarg1;
  delete arg1;
}


SWIGEXPORT jlong JNICALL Java_com_navbuilder_nb_analytics_internal_jni_analytics_1wrapperJNI_new_1AnalyticsListener(JNIEnv *jenv, jclass jcls) {
  jlong jresult = 0 ;
  nbcommon::AnalyticsListener *result = 0 ;

  (void)jenv;
  (void)jcls;
  result = (nbcommon::AnalyticsListener *)new SwigDirector_AnalyticsListener(jenv);
  *(nbcommon::AnalyticsListener **)&jresult = result;
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_navbuilder_nb_analytics_internal_jni_analytics_1wrapperJNI_delete_1AnalyticsListener(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  nbcommon::AnalyticsListener *arg1 = (nbcommon::AnalyticsListener *) 0 ;

  (void)jenv;
  (void)jcls;
  arg1 = *(nbcommon::AnalyticsListener **)&jarg1;
  delete arg1;
}


SWIGEXPORT void JNICALL Java_com_navbuilder_nb_analytics_internal_jni_analytics_1wrapperJNI_AnalyticsListener_1director_1connect(JNIEnv *jenv, jclass jcls, jobject jself, jlong objarg, jboolean jswig_mem_own, jboolean jweak_global) {
  nbcommon::AnalyticsListener *obj = *((nbcommon::AnalyticsListener **)&objarg);
  (void)jcls;
  SwigDirector_AnalyticsListener *director = dynamic_cast<SwigDirector_AnalyticsListener *>(obj);
  if (director) {
    director->swig_connect_director(jenv, jself, jenv->GetObjectClass(jself), (jswig_mem_own == JNI_TRUE), (jweak_global == JNI_TRUE));
  }
}


SWIGEXPORT void JNICALL Java_com_navbuilder_nb_analytics_internal_jni_analytics_1wrapperJNI_AnalyticsListener_1change_1ownership(JNIEnv *jenv, jclass jcls, jobject jself, jlong objarg, jboolean jtake_or_release) {
  nbcommon::AnalyticsListener *obj = *((nbcommon::AnalyticsListener **)&objarg);
  SwigDirector_AnalyticsListener *director = dynamic_cast<SwigDirector_AnalyticsListener *>(obj);
  (void)jcls;
  if (director) {
    director->swig_java_change_ownership(jenv, jself, jtake_or_release ? true : false);
  }
}


SWIGEXPORT jlong JNICALL Java_com_navbuilder_nb_analytics_internal_jni_analytics_1wrapperJNI_AnalyticsEngine_1GetInstance(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  jlong jresult = 0 ;
  nbcommon::AnalyticsEngine *result = 0 ;

  (void)jenv;
  (void)jcls;
  NativeLTKContext* nativenbcontext = reinterpret_cast<NativeLTKContext*>(jarg1);
  result = (nbcommon::AnalyticsEngine *)nbcommon::AnalyticsEngine::GetInstance(nativenbcontext->nbContext);
  *(nbcommon::AnalyticsEngine **)&jresult = result;
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_navbuilder_nb_analytics_internal_jni_analytics_1wrapperJNI_AnalyticsEngine_1Initialize(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jstring jarg3) {
  jint jresult = 0 ;
  nbcommon::AnalyticsEngine *arg1 = (nbcommon::AnalyticsEngine *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  NB_Error result;

  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(nbcommon::AnalyticsEngine **)&jarg1;
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null string");
    return 0;
  }
  const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
  if (!arg2_pstr) return 0;
  std::string arg2_str(arg2_pstr);
  arg2 = &arg2_str;
  jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
  if(!jarg3) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null string");
    return 0;
  }
  const char *arg3_pstr = (const char *)jenv->GetStringUTFChars(jarg3, 0);
  if (!arg3_pstr) return 0;
  std::string arg3_str(arg3_pstr);
  arg3 = &arg3_str;
  jenv->ReleaseStringUTFChars(jarg3, arg3_pstr);
  result = (NB_Error)(arg1)->Initialize((std::string const &)*arg2,(std::string const &)*arg3);
  jresult = (jint)result;
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_navbuilder_nb_analytics_internal_jni_analytics_1wrapperJNI_AnalyticsEngine_1AddAnalyticsEvent(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jint jresult = 0 ;
  nbcommon::AnalyticsEngine *arg1 = (nbcommon::AnalyticsEngine *) 0 ;
  std::string *arg2 = 0 ;
  NB_Error result;

  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(nbcommon::AnalyticsEngine **)&jarg1;
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null string");
    return 0;
  }
  const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
  if (!arg2_pstr) return 0;
  std::string arg2_str(arg2_pstr);
  arg2 = &arg2_str;
  jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
  result = (NB_Error)(arg1)->AddAnalyticsEvent((std::string const &)*arg2);
  jresult = (jint)result;
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_navbuilder_nb_analytics_internal_jni_analytics_1wrapperJNI_AnalyticsEngine_1NoticeAlive(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  nbcommon::AnalyticsEngine *arg1 = (nbcommon::AnalyticsEngine *) 0 ;
  NB_Error result;

  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(nbcommon::AnalyticsEngine **)&jarg1;
  result = (NB_Error)(arg1)->NoticeAlive();
  jresult = (jint)result;
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_navbuilder_nb_analytics_internal_jni_analytics_1wrapperJNI_AnalyticsEngine_1KeepAlive(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jboolean jarg2) {
  jint jresult = 0 ;
  nbcommon::AnalyticsEngine *arg1 = (nbcommon::AnalyticsEngine *) 0 ;
  bool arg2 ;
  NB_Error result;

  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(nbcommon::AnalyticsEngine **)&jarg1;
  arg2 = jarg2 ? true : false;
  result = (NB_Error)(arg1)->KeepAlive(arg2);
  jresult = (jint)result;
  return jresult;
}


SWIGEXPORT jbyteArray JNICALL Java_com_navbuilder_nb_analytics_internal_jni_analytics_1wrapperJNI_AnalyticsEngine_1GetSessionId(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  nbcommon::AnalyticsEngine *arg1 = (nbcommon::AnalyticsEngine *) 0 ;
  std::string result;

  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(nbcommon::AnalyticsEngine **)&jarg1;
  result = (arg1)->GetSessionId();
  jbyteArray jresult = jenv->NewByteArray(result.length());
  jenv->SetByteArrayRegion(jresult, 0, result.length(), (jbyte*)result.c_str());
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_navbuilder_nb_analytics_internal_jni_analytics_1wrapperJNI_AnalyticsEngine_1MasterClear(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  nbcommon::AnalyticsEngine *arg1 = (nbcommon::AnalyticsEngine *) 0 ;
  NB_Error result;

  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(nbcommon::AnalyticsEngine **)&jarg1;
  result = (NB_Error)(arg1)->MasterClear();
  jresult = (jint)result;
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_navbuilder_nb_analytics_internal_jni_analytics_1wrapperJNI_AnalyticsEngine_1ForceUpload(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  nbcommon::AnalyticsEngine *arg1 = (nbcommon::AnalyticsEngine *) 0 ;
  NB_Error result;

  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(nbcommon::AnalyticsEngine **)&jarg1;
  result = (NB_Error)(arg1)->ForceUpload();
  jresult = (jint)result;
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_navbuilder_nb_analytics_internal_jni_analytics_1wrapperJNI_AnalyticsEngine_1SetDataRoaming(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jboolean jarg2) {
  jint jresult = 0 ;
  nbcommon::AnalyticsEngine *arg1 = (nbcommon::AnalyticsEngine *) 0 ;
  bool arg2 ;
  NB_Error result;

  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(nbcommon::AnalyticsEngine **)&jarg1;
  arg2 = jarg2 ? true : false;
  result = (NB_Error)(arg1)->SetDataRoaming(arg2);
  jresult = (jint)result;
  return jresult;
}


SWIGEXPORT jint JNICALL Java_com_navbuilder_nb_analytics_internal_jni_analytics_1wrapperJNI_AnalyticsEngine_1SetAnalyticsListener(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jint jresult = 0 ;
  nbcommon::AnalyticsEngine *arg1 = (nbcommon::AnalyticsEngine *) 0 ;
  nbcommon::AnalyticsListener *arg2 = (nbcommon::AnalyticsListener *) 0 ;
  NB_Error result;

  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(nbcommon::AnalyticsEngine **)&jarg1;
  arg2 = *(nbcommon::AnalyticsListener **)&jarg2;
  result = (NB_Error)(arg1)->SetAnalyticsListener(arg2);
  jresult = (jint)result;
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_com_navbuilder_nb_analytics_internal_jni_analytics_1wrapperJNI_AnalyticsEngine_1GetAnalyticsWifiConfig(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  nbcommon::AnalyticsEngine *arg1 = (nbcommon::AnalyticsEngine *) 0 ;
  nbcommon::AnalyticsWifiConfig *result = 0 ;

  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(nbcommon::AnalyticsEngine **)&jarg1;
  result = (nbcommon::AnalyticsWifiConfig *)((nbcommon::AnalyticsEngine const *)arg1)->GetAnalyticsWifiConfig();
  *(nbcommon::AnalyticsWifiConfig **)&jresult = result;
  return jresult;
}


SWIGEXPORT void JNICALL Java_com_navbuilder_nb_analytics_internal_jni_analytics_1wrapperJNI_swig_1module_1init(JNIEnv *jenv, jclass jcls) {
  int i;

  static struct {
    const char *method;
    const char *signature;
  } methods[1] = {
    {
      "SwigDirector_AnalyticsListener_OnSessionCreated", "(Lcom/navbuilder/nb/analytics/internal/jni/AnalyticsListener;[B[B)V"
    }
  };
  Swig::jclass_analytics_wrapperJNI = (jclass) jenv->NewGlobalRef(jcls);
  if (!Swig::jclass_analytics_wrapperJNI) return;
  for (i = 0; i < (int) (sizeof(methods)/sizeof(methods[0])); ++i) {
    Swig::director_methids[i] = jenv->GetStaticMethodID(jcls, methods[i].method, methods[i].signature);
    if (!Swig::director_methids[i]) return;
  }
}


#ifdef __cplusplus
}
#endif

